### Python 문법 기초: `__init__`, `__all__`, 언더스코어(`_`) 관례 정리

### `__init__`

**클래스의 생성자 메서드**로, **객체 생성 시 자동 호출**됩니다.

```python
class User:
    def __init__(self, name: str):
        self.name = name

u = User("Alice")  # __init__ 호출
```

### `__all__`

**모듈의 공개 API를 명시**하는 리스트입니다.

`from module import *` 사용 시, **`__all__`에 있는 항목만** 가져옵니다.
<br>
절대경로를 사용한다면 패키지 하위에 있는 __init\__.py에 명시해서 사용할 수 있습니다.
```python
# my_module.py
__all__ = ["func_a", "ClassB"]

def func_a():
    ...

def _internal():
    ...

class ClassB:
    ...
```

```python
from my_module import *  # _internal은 import되지 않음
```

### `_` (싱글 언더스코어)

1. 내부 전용(비공개) 관례
```python
def _private_helper():
    pass  # 외부에서 사용하지 말라는 암묵적 의미
```

2. 사용하지 않는 값 무시(예: 반복문 변수)
```python
for _ in range(3):
    print("Hello")  # i 값을 쓰지 않음
```

3. REPL에서 마지막 결과 참조
```python
>>> 3 + 4
7
>>> _ * 2
14
```

### `__something__` (더블 언더스코어, '던더')

- Python이 정의한 **특수 메서드/속성** 이름 공간입니다.
- e.g. `__init__`, `__str__`, `__repr__`, `__name__`, `__file__`
- **사용자 정의로 임의 생성은 권장되지 않음**(내부 예약 네이밍과 충돌 가능)
- 	__init\__: 인스턴스 초기화 메서드(생성자)로, 객체 생성 직후 상태를 설정하며 값을 반환하지 않는다.<br> 
- 	__str\__: 사람 친화적 문자열 표현을 반환해 print(obj), f"{obj}" 등에서 사용된다. <br>
- 	__repr\__: 개발자·디버깅용 표현을 반환하며 가능하면 객체를 재생성할 수 있는 형태를 지향한다(없으면 __str\__ 대신 사용됨). <br>
-	__name\__: 모듈,함수,클래스의 이름을 담고, 모듈 파일을 직접 실행하면 모듈의 __name__은 "__main\__"이 된다.<br>
-	__file\__: 모듈이 로드된 파일 경로를 나타내며, 파일 기반 모듈에서만 존재한다(예: 패키지는 __init\__.py 경로).<br>

### `__slots__`

**동적 속성 추가를 제한**하고 **메모리 사용을 최적화**합니다.

```python
class Point:
    __slots__ = ["x", "y"]
    def __init__(self, x, y):
        self.x = x
        self.y = y
```

### 언더스코어 변수명 정리 요약

| 형태 | 의미/효과                                                             |
|------|-------------------------------------------------------------------|
| `_var` | **비공개(non-public)** 관례. 외부에서 사용 자제 권고                             |
| `__var` | **네임 맹글링(name mangling)** 적용 -> `_ClassName__var`로 바뀌어 외부 접근이 어려움 |
| `__var__` | **Python 예약 특수 이름**(던더). 내부 프로토콜용으로만 사용 권장                        |

```python
class Example:
    def __init__(self):
        self.__hidden = "secret"

e = Example()
# print(e.__hidden)        # AttributeError
print(e._Example__hidden)   # "secret" (name mangling 결과)
```

## 참고 요약

- `__init__`: 생성자
- `__all__`: 모듈의 공개 심볼 목록
- `_`: 내부용/무시 변수/REPL 마지막 값
- `__something__`: 특수 메서드/속성 네임스페이스
- `__slots__`: 속성 제한 + 메모리 최적화
- 네임 맹글링(name mangling): 클래스 본문에서 정의된 식별자 이름을 컴파일 단계에서 바꿔 붙이는 규칙<br>
   - 서브클래스와 우연한 이름 충돌 피하는 목적
   - e.g.  __secret: 적용됨, __secret\__ : 미적용: dunder는 예약
     - 클래스 본문 안에서 정의, 참조한 이름에 한해 적용됨
   - __name -> &nbsp; _\<ClassName>\__name 으로 변환
   - ```python
     class Base:
     __token = "BASE"           # -> _Base__token 으로 맹글링
     def __hello(self):         # -> _Base__hello
        return self.__token
     def expose(self):
        return self.__hello()  # 내부 참조는 자동으로 맹글링된 이름을 사용
     
     b = Base()
     print(b.expose())              # "BASE"
     # print(b.__hello())          # AttributeError
     print(b._Base__hello())        # 우회 호출 가능
     # print(b.__dict__)              # {'_Base__token': 'BASE'}
     ```
   - 캡슐화, 은닉이 필요하다면 모듈 경계, 프로퍼티, 컴포지션, 접근 제어 로직으로 해결 권장